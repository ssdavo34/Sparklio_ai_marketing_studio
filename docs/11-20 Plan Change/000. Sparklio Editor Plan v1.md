# Sparklio Editor Plan v1  
Polotno → LayerHub 전환 전략 + 단계별 구현 지침  
(Claude Code 전용 작업지시서)

---

## 0. 프로젝트 목적 요약

Sparklio는 “Canva + 마케팅 AI 에이전트”를 목표로 하는 웹 서비스입니다.

핵심 목표:

1. **브리프 / 회의록 / 브랜드 정보**를 입력하면  
2. **LLM + Brand Kit + Meeting AI**가  
3. **컨셉보드 / 카드뉴스 / 슬라이드**를 자동으로 제안하고  
4. 사용자는 **에디터에서 편집 → Export / 배포**까지 할 수 있는 시스템

현재 상황:

- Next.js 프론트엔드, `/studio` 라우트에 Konva 기반 초기 에디터가 있음.
- 에디터 구현에 시간이 너무 많이 소모되어,  
  전체 Sparklio 플로우(LLM, Generator, Meeting AI 등)의 진도가 막혀 있음.
- 해결 전략:
  - **단기:** Polotno로 에디터 v1을 빠르게 완성해서 전체 플로우를 살린다.
  - **중장기:** LayerHub(오픈소스)를 기반으로 자체 에디터 v2를 개발하고,  
    상용화 시점에 Polotno → LayerHub로 교체한다.

---

## 1. Claude 작업 원칙 (반드시 지킬 규칙)

1. **Golden 상태 보존**
   - 현재 Konva 기반 `/studio` 레이아웃은 “역사적 참고용”으로만 사용.
   - 기존 파일 구조를 대형 리팩터링하지 말고,  
     Polotno / LayerHub는 **새 라우트 / 새 컴포넌트**로 붙인다.

2. **엔진-독립 데이터 모델 도입**
   - Polotno, LayerHub 각각의 JSON 포맷을 그대로 DB에 저장하지 않는다.
   - 반드시 `SparklioDocument`라는 **중간 모델**을 정의하고,  
     Adapter를 통해 각 에디터 엔진과 연결한다.

3. **작업 단위는 작게, 각 단계마다 완결**
   - “한 번에 대공사” 금지.  
   - 항상 다음 패턴으로 작업:
     1) 관련 파일 READ  
     2) 변경 계획 설명  
     3) 전체 코드 제시  
     4) 빌드/실행 가정 후, 문제 가능성 있으면 언급

4. **로컬 경로 / 브랜치 가정**
   - 프론트엔드 루트:  
     `K:\sparklio_ai_marketing_studio\frontend`
   - 작업용 브랜치 (예시):  
     `feature/editor-polotno-layerhub-v1`

5. **Typescript / React / Next.js 규칙**
   - `app` 라우터 기준 (`app/studio/...`)
   - 에디터 관련 코드는 최대한 `components/canvas-studio/` 또는  
     별도 `components/editor/` 하위에 정리.
   - 스타일은 Tailwind 사용(이미 프로젝트에 적용되어 있다고 가정).

---

## 2. 전체 단계 구조 (큰 그림)

### Phase 1. 실험 라인 오픈

- Polotno / LayerHub **둘 다** 붙여서 실험 페이지를 만든다.
- 기존 Konva 에디터는 `/studio/konva` 같은 별도 라우트로 옮겨 “기념관”으로 보존.

### Phase 2. SparklioDocument 도입

- 엔진과 무관한 **Sparklio 고유 문서 모델**을 정의한다.
- Polotno ↔ SparklioDocument 변환 Adapter를 만든다.

### Phase 3. Polotno 기반 Sparklio Studio v1 완성

- `/studio` 메인은 Polotno로 동작.
- 좌/우 패널에 Spark Chat / Meeting AI / Brand Kit 탭 통합.
- LLM API와 최소한의 연동.

### Phase 4. LayerHub 기반 Editor v2 개발 (중장기)

- `/lab/layerhub` 라우트에서 LayerHub 기반 에디터를 개발.
- SparklioDocument ↔ LayerHub Adapter 구현.
- Polotno v1을 참고하여 기능/UX를 맞춰간다.

---

## 3. 단계별 상세 작업 지시

### ✅ STEP 0. 준비

**목표:** 안전한 작업 환경과 브랜치 확보

1. 프론트엔드 루트로 이동  
   - `K:\sparklio_ai_marketing_studio\frontend`

2. Git 상태 확인  
   - `git status` 기준으로 작업 디렉토리 상태를 파악한다.  
   - 변경사항이 많다면, 우선 임시 커밋 또는 stash를 고려한다.

3. 새 브랜치 생성 (예시)  
   - `git checkout -b feature/editor-polotno-layerhub-v1`

> 이후 모든 코드는 이 브랜치 기준으로 작업한다.

---

### ✅ STEP 1. 라우트 구조 정리: Polotno / LayerHub / Konva 분리

**목표:**  
에디터 3종을 안전하게 병행 테스트할 수 있는 라우트 구성

**해야 할 일:**

1. **Konva 기존 에디터를 `/studio/konva`로 이동**
   - 현재 `/studio`에서 사용하는 페이지/컴포넌트를 확인.
   - 예시:
     - `app/studio/page.tsx`  
       → Konva 기반 `CanvasStudioShell`을 import하고 있다면,
   - 작업:
     - `app/studio/page.tsx` 내용을  
       `app/studio/konva/page.tsx`로 복사/이동.
     - `app/studio/page.tsx`는 일단 빈 페이지 또는 임시 안내 페이지로 남겨둔다.

2. **Polotno 테스트 페이지 생성 `/studio/polotno`**
   - 파일: `app/studio/polotno/page.tsx`
   - SSR 비활성화를 위해 `dynamic` import 사용.
   - 최소 예시:

     ```tsx
     'use client';

     import dynamic from 'next/dynamic';

     const PolotnoApp = dynamic(
       () => import('@/components/editor/polotno/PolotnoApp').then(m => m.PolotnoApp),
       { ssr: false }
     );

     export default function PolotnoStudioPage() {
       return <PolotnoApp />;
     }
     ```

3. **LayerHub 테스트 페이지 생성 `/studio/layerhub`**
   - 파일: `app/studio/layerhub/page.tsx`
   - 마찬가지로 `dynamic` import 사용.
   - 최소 예시:

     ```tsx
     'use client';

     import dynamic from 'next/dynamic';

     const LayerhubApp = dynamic(
       () => import('@/components/editor/layerhub/LayerhubApp').then(m => m.LayerhubApp),
       { ssr: false }
     );

     export default function LayerhubStudioPage() {
       return <LayerhubApp />;
     }
     ```

4. **상단 내비게이션에서 3개 라우트 링크 추가 (선택)**
   - `components/Layout/Navigation.tsx` 등에서
     - “Polotno”, “LayerHub”, “Konva (legacy)” 메뉴 추가 가능.

---

### ✅ STEP 2. Polotno 기본 에디터 붙이기

**목표:** `/studio/polotno` 에서 Polotno 기본 에디터가 뜨는 상태

1. 의존성 설치 (설치 안 되어 있다면)
   - `npm install polotno @blueprintjs/core`

2. 컴포넌트 생성  
   - 파일: `components/editor/polotno/PolotnoApp.tsx`

   - 기본 구조(Claude가 구현):

     ```tsx
     'use client';

     import { PolotnoContainer, SidePanelWrap, WorkspaceWrap } from 'polotno/polotno-app';
     import { createStore } from 'polotno/model/store';

     const store = createStore({
       key: 'YOUR_POLOTNO_KEY', // 현재는 테스트 용도, 실제 Key는 .env로 뺄 것
     });

     export function PolotnoApp() {
       return (
         <div className="flex h-screen bg-neutral-900 text-white">
           <PolotnoContainer className="w-full h-full">
             <SidePanelWrap>
               {/* TODO: 좌측 사이드바 (페이지, 템플릿, 업로드 등) */}
             </SidePanelWrap>
             <WorkspaceWrap />
           </PolotnoContainer>
         </div>
       );
     }
     ```

   - **주의:** 실제 Key / 라이선스 관련 코드는 나중에 .env로 분리하고,  
     현재는 “학습/테스트” 용도로만 사용.

3. `/studio/polotno` 접속 시 에러 없이 Polotno가 뜨는지 확인.

---

### ✅ STEP 3. LayerHub 기본 에디터 붙이기

**목표:** `/studio/layerhub` 에서 LayerHub 기본 에디터가 뜨는 상태

1. 의존성 설치
   - `npm install @layerhub-io/react`

2. 최소 컴포넌트 생성  
   - 파일: `components/editor/layerhub/LayerhubApp.tsx`

   - 예시(Claude가 공식 예제를 참고해 작성):

     ```tsx
     'use client';

     import { DesignEditor } from '@layerhub-io/react';

     export function LayerhubApp() {
       return (
         <div className="flex h-screen bg-neutral-900 text-white">
           <div className="flex-1">
             <DesignEditor
               onSave={data => {
                 console.log('Layerhub design data', data);
               }}
             />
           </div>
         </div>
       );
     }
     ```

3. `/studio/layerhub` 접속 시 에러 없이 LayerHub 에디터가 뜨는지 확인.

---

### ✅ STEP 4. SparklioDocument 모델 도입

**목표:** 엔진과 상관없는 Sparklio 고유 문서 모델 정의

1. 타입 정의 파일 생성  
   - 위치: `frontend/lib/sparklio/document.ts`

   ```ts
   // lib/sparklio/document.ts

   export type SparklioElementType = 'text' | 'image' | 'shape' | 'frame';

   export interface SparklioElement {
     id: string;
     type: SparklioElementType;
     x: number;
     y: number;
     width: number;
     height: number;
     rotation?: number;
     props: Record<string, any>; // 색, 폰트, 텍스트 등의 스타일 정보
   }

   export interface SparklioPage {
     id: string;
     name: string;
     elements: SparklioElement[];
   }

   export interface SparklioDocument {
     id: string;
     kind: 'concept_board' | 'banner' | 'slide';
     title?: string;
     pages: SparklioPage[];
     brandId?: string;
     createdAt?: string;
     updatedAt?: string;
   }
```

2. 이 모델은 앞으로
    
    - LLM 결과,
        
    - DB 저장 구조,
        
    - Meeting AI 출력 구조의 기준이 된다.
        

---

### ✅ STEP 5. Polotno ↔ SparklioDocument Adapter 뼈대 만들기

**목표:** Polotno 전용 JSON과 SparklioDocument를 매핑하는 구조 준비

1. Adapter 파일 생성
    
    - 위치: `lib/sparklio/adapters/polotno-adapter.ts`
        
    
    ```ts
    import type { SparklioDocument } from '../document';
    ```
    

// Polotno 내부 데이터 타입은 우선 any로 두고,  
// 나중에 실제 타입 정의를 추가한다.  
export function sparklioToPolotno(doc: SparklioDocument): any {  
// TODO: SparklioDocument → Polotno project 변환 로직  
return {};  
}

export function polotnoToSparklio(polotnoData: any): SparklioDocument {  
// TODO: Polotno project → SparklioDocument 변환 로직  
return {  
id: 'temp',  
kind: 'concept_board',  
title: 'Temp',  
pages: [],  
};  
}

````

2. 현재 단계에서는 **구현보다는 구조**가 중요하다.
- 이후 Polotno의 실제 saved design 구조를 콘솔로 확인해가며  
  이 Adapter를 점진적으로 구현한다.

---

### ✅ STEP 6. `/studio` 메인을 Polotno 기반 Studio v1으로 전환

**목표:** 학원 발표/데모용 메인 에디터를 Polotno로 완성

1. `app/studio/page.tsx`를 갱신하여,  
`/studio`에서 Polotno를 메인으로 사용.

```tsx
'use client';

import dynamic from 'next/dynamic';

const PolotnoApp = dynamic(
  () => import('@/components/editor/polotno/PolotnoApp').then(m => m.PolotnoApp),
  { ssr: false }
);

export default function StudioPage() {
  return <PolotnoApp />;
}
````

2. `PolotnoApp` 레이아웃에 오른쪽 패널 추가 (Spark Chat / Meeting AI / Brand Kit 탭)
    
    - 기존 RightDock/ChatInterface/BrandKit 컴포넌트가 있다면,
        
        - Polotno의 Workspace 오른쪽에 `div`로 감싸서 병합.
            
    
    예시 구조 (상세 구현은 Claude에게 맡김):
    
    ```tsx
    <div className="flex h-screen bg-neutral-900 text-white">
      <div className="flex-1">
        {/* Polotno Editor */}
      </div>
      <div className="w-[360px] border-l border-neutral-800 bg-neutral-900">
        {/* Tabs: Spark Chat / Meeting AI / Brand Kit */}
      </div>
    </div>
    ```
    
3. 이 단계의 목표:
    
    - Polotno 에디터 + 우측 패널 + 상단 네비까지  
        “Sparklio Studio v1”로 보일 수 있도록 UI 완성.
        

---

### ✅ STEP 7. LayerHub v2 준비 (중장기, 실험용)

**목표:** LayerHub 기반 차세대 에디터 개발 준비

1. `lib/sparklio/adapters/layerhub-adapter.ts` 생성
    
    - `SparklioDocument ↔ LayerHub` 변환 함수 시그니처만 정의.
        
2. `/studio/layerhub` 페이지에서
    
    - 향후 `SparklioDocument`를 불러와 렌더할 수 있도록 구조만 설계.
        
    - 초기에는 단순히 LayerHub 기본 에디터만 보여주고,  
        콘솔에 save 데이터 로그를 찍는 정도로 유지.
        
3. 이 부분은 학습/연습용으로 천천히 진행하며,  
    상용화 시점에 Polotno를 LayerHub로 스왑하기 위한 기반으로 사용한다.
    

---

## 4. Claude에게 바라는 작업 방식 요약

1. **각 Step마다 다음 순서로 응답해줘:**
    
    1. 현재 코드/구조 이해 요약 (READ 결과)
        
    2. 변경 계획 요약
        
    3. 수정된 전체 코드 (파일 단위)
        
    4. 잠재적인 문제점 / TODO 리스트
        
2. **에러가 나면, 원인 분석 + 수정 코드까지 한 세트로 제안해줘.**
    
3. **Konva 기반 기존 코드**는:
    
    - 최대한 삭제하지 말고,
        
    - `/studio/konva` 등 별도 라우트로 옮겨 “레거시/비교용”으로 둔다.
        
4. **이 문서(계획서)를 항상 1번 기준으로 삼고,  
    내가 중간에 다른 이야기를 하더라도,  
    이 전략에서 크게 벗어나지 않는 선에서 제안해줘.**
    

---

## 5. 최종 목표 (이번 계획서 기준)

- `/studio` → Polotno 기반 Sparklio Studio v1 (학원 발표용 + 프로토타입)
    
- `/studio/polotno` → 동일 또는 실험 확장용
    
- `/studio/layerhub` → LayerHub 기반 v2 실험장
    
- `/studio/konva` → 기존 Konva 에디터 보존용
    
- `SparklioDocument` 모델 + Polotno Adapter 뼈대 완료
    

이 상태만 만들어도:

- 에디터 병목이 해소되고,
    
- Sparklio 전체 플로우(LLM, Brand, Meeting AI)를 올릴 수 있는 발판이 확보되며,
    
- 나중에 LayerHub로 교체할 수 있는 **구조적 준비**까지 끝납니다.
    
